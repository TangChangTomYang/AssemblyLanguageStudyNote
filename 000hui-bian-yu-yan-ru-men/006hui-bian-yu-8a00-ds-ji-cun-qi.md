#DS数据段寄存器

## 一、访问内存中的数据
- 内存地址的表示方式
> 方式1， 段地址(ds):[偏移地址]

   > 方式2，[偏移地址]， 这种写法等价于 ds:[偏移地址]

- 将16进制数据1122，移动到通用寄存器 ax 当中
> mov ax，1122h  

- 将16进制数据3344，移动到通用寄存器 bx 当中
> mov bx，3344h  

- 将通用寄存器ax的低位数值(使用al表示)添加到通用寄存器的高位(bh)当中
> add bh，al

&emsp;最终bx中的数值为结果为：bx = 5544H

- 将通用寄存器bx的低位数据添加到通用寄存器ax的高位
> add ah , bl 

&emsp;最终结果为：ax = 5522H 

**注意在汇编语言中注释不是写 // 而是写 ; (分号表示注释)**


##二、DS 和 [address]  ，内存地址

**说明：**
**我们要往 寄存器 或者 内存 中放值都是通过mov 指令来完成。**

- CPU 要读写一个内存单元时，必须要先给出这个内存单元的地址，在8086 中，内存单元的地址由 段地址和偏移地址组成。

- 8086 中有一个**DS段寄存器**，通常用来存放要访问数据的段地址（数据段地址data segment）
> mov bx, 10000h
   mov ds,  bx
   mov al，[0]   // 表示将**内存中** 数据段地址 ds:[0] 对应的一个字节的数据写入al 通用寄存器中。

*(1)上面3条指令的作用是将10000H(1000:0) 中的内存数据复制到al寄存器中.
(2)mov al, [address] 的意思将DS:address 中的内存数据赋值到al寄存器中。
(3)由于al 是8位寄存器，所以是将一个字节的数据赋值给al寄存器*

- 8086 不支持直接将数据写入段寄存器，**mov ds, 1000H 是错误的。**, 即,不能直接将数据赋值给段寄存器,必须通过通用寄存器转换一次


##二、访问内存中的数据
内存地址的表示： **段地址:[偏移地址]，注意段地址不能直接写数值而必须有段地址寄存器来提供**。比如：

**错误写法(一)：**
> mov ax 1122h
   mov 1000h:[0h]  ,ax   // 内存地址不能直接使用数值(1000h:[0h])表示,需要由段地址寄存器来提供

**错误写法(二)：**
> mov ax, 1122h
   mov ds, 1000h  // 是不能直接将数据写入段寄存器的
   mov ds:[0], ax

**正确写法(一)：**
> mov ax， 1122h
   mov bx, 1000h  // 现将内存段地址写书数据寄存器中
   mov ds,bx         // 将数据寄存器中的内存段地址写入 数据段寄存器中
  mov ds:[0]， ax  // 将数据段寄存器中的数据 写入内存地址（ds:[0]） 中.

**正确写法(二)**
> mov ax， 1122h
   mov bx, 1000h  
   mov ds,bx   
  mov [0]， ax  // 在8086 汇编中默认存内存中读取或写如数据时 段地址是数据段地址（ds -- data segment ）,因此 数据段地址 ds: 可以不写 和 ds: [xxxx] 表达的是一个意思。


##三、练习

写几条指令，将al 中的数据写入内存单元 10000H中

写法一：
> mov bx, 1000h
  mov ds, bx
  mov ds:[0], ax  

写法二：
> mov bx， 1000h
   mov ds, bx
   mov [0], ax

**指令含义解释说明：**
  （1）mov bx， 1000h，表示将数值 1000h 写入通用寄存器 bx中，
  （2） mov ds, bx，表示将通用寄存器bx中的数值表示的数据写入数据段寄存中ds中，让段地址寄存器指向 bx数据表示的内存地址
     (3) mov ds:[0], ax , 表示将通用寄存器ax中的数值写入  ds:[0] 指向的内存地址
   （4）mov [0], ax  等价于  mov ds:[0], ax

##四、字型数据的传递(2个字节)

![字型数据的传递(2个字节).png](http://upload-images.jianshu.io/upload_images/2018969-a2a76cd7157bc28b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##五、大小端

- 大端模式，是指数据的**高字节**保存在内存的**低地址**中，而数据的**低字节**保存在内存的**高地址**中(高低\底高) (Big Endian)

- 小端模式，是指数据的**高字节**保存在内存的**高地址**中，数据的低字节保存在内存的**地地址**中（高高\底底）(Little Endian)

![大小端.png](http://upload-images.jianshu.io/upload_images/2018969-2cee6753e2a12f95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##六、add 和 sub 指令

add 和 sub指令同mov 指令一样，都是两个操作对象。他们也可以有以下几种操作模式：


>add 寄存器，数据   //比如：add ax，8
add 寄存器，寄存器  //比如：add ax,bx
add 寄存器， 内存单元 // add ax ,[0]
add 内存单元，寄存器  // add [0], ax

>sub 寄存器，数据  // sub ax,8
sub 寄存器，寄存器 // sub ax,bx
sub 寄存器，内存单元 // sub AX, [0]
sub 内存单元，寄存器 // sub [0]


##七、 访问数据的歧义

- 歧义一
   mov ax, 1000h
   mov ds,ax
   mov [0],66h  // 这样写不清楚写入内存中的数据时一个字节（66）呢还是2个字节（0066h）

**因此在汇编中为了解决这种歧义我们这样写:表示一个字节**
>   mov ax, 1000h
   mov ds,ax
   mov byte  ptr [0],66h  // 这样写明确写入一个字节**byte** 表示一个字节  **ptr** 是固定的格式写法

**因此在汇编中为了解决这种歧义我们这样写:表示一个字，两个字节**
>   mov ax, 1000h
   mov ds,ax
   mov word  ptr [0],66h  // 这样写明确写入一个字一个字，两个字节**word** 表示一个字  **ptr** 是固定的格式写法
































