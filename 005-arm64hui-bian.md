其实学习汇编我们主要从3个方面着手：
（1）、寄存器
（2）、指令
（3）、堆栈




##一、指令
- 1、 **mov**<br><br>**格式：**
```
mov 目的寄存器， 源操作数
或者
mov {条件}{s}目的寄存器， 源操作数
```
**作用：**<br>将一个寄存器 或者一个被移位的寄存器 或者一个立即数 加载到目标寄存器的功能。其中 **s** 选项决定指令的操作是否影响 **cpsr**中的条件标志位的值。当没有**S** 时指令不更新**cpsr** 中条件标志位的值。<br><br>
**常用示例：**

    ```
    mov r1,r0           // 将寄存器r0的值传送到寄存器r1
    mov pc,r14          // 将寄存器r14中的值传送机pc寄存器中，常用于子程序返回（即 bl 函数调用返回调用函数的位置）
    mov r0, #12         // 将立即数#12 传送到寄存器r0 中
    mov r1, r0,lsl#3    // 将寄存器r0 中的值左移3位后传送到r1寄存器中
    ```
<br><br>

- 2、 **ret**<br><br>**作用：**<br>汇编函数执行完毕返回（结束）指令。<br><br>**本质：**<br> 其实当程序执行**ret** 指令时，其本质是将**rl（x30）**中的值传送到**pc**中（pc 中的值就是正在执行的指令的地址） 这样就达到了程序流程的跳转。
    
<br><br>


- 3、**add**<br><br>**格式：**
```
add 目的寄存器，源操作数1， 源操作数2
或者
add {条件}{S} 目的寄存器，源操作数1， 源操作数2
```
**作用：**<br> 将2个操作数相加，并将结果传送到目的寄存器，**源操作数1 必须是一个寄存器，源操作数2可以是一个寄存器或者被位移的寄存器或者是一个立即数。**
<br><br>
**常用示例：**
```
add r0，r1,r2    //r0=r1+r2
add r0,r1,#3    //r0= r1+#3
add r0,r1,r2, lsl#3    // r0= r1+(r2<<3)
```

<br><br>
- 4、**sub**<br><br>**格式：**
```
sub 目的寄存器，源操作数1，源操作数2
或者
sub {条件}{S}目的寄存器，源操作数1，源操作数2
```
**作用：**<br>
把源操作数1 减去源操作数2，并将结果传送到目的寄存器中，**源操作数必须是一个寄存器，源操作数可以是一个寄存器 或者被位移的寄存器 或者一个立即数**，该指令用于有符号和无符号数的减法运算。
<br><br>
**常用示例：**
```
sub r0,r1,r2    //r0= r1-r2
sub r0,r1,r2,lsl#2     //r0= r1 - (r2<< 2)
sub r0,r2,#245    // r0= r2-#245
```






<br><br>
- 5、 **cmp**<br><br>**格式：**
```
cmp 操作数1， 操作数2
或者
cmp {条件} 操作数1，操作数2
```
**作用：**<br>
用于将一个寄存器的内容和另一个寄存器的内容或立即数进行比较，更具比较结果更新cpsr中的标志位的值。该指令进行一次减法运算，但不存储结果，只是更新cpsr中标志位的值
<br>
**常用示例：**

    ```
  cmp r1,r0    //将寄存器r1和r0的值相减，并根据结果更新cpsr中的标志位
  cmp r1,#199    // 将寄存器r1和立即数#199的值相减，并根据结果更新cpsr中的标志位
    ```
    
    
<br><br>
- 6、 **b**<br><br>**格式：**
```
b 目标地址
或者
b {条件} 目标地址
```
**作用：**<br> b 指令是最简单的跳转指令，一旦遇到一个b 指令，arm 处理器将。不带返回的跳转。
<br>
**常用示例：**

    ```
  b label        // 程序无条件跳转到标号label 处继续执行
  cmp r1,#12     // 当 cpsr 寄存器中的z条件码=1时，程序跳转到标号label2处执行
  beq label2
    ```



<br><br>
- 7、 **bl**<br><br>**格式：**
```
bl 目标地址
或者
bl {条件} 目标地址
```
**作用：**<br>
带返回的b指令（相当于是函数调用）
<br>
**常用示例：**

    ```
    .text
    .global _text

    //内部私有函数
    mycode：
    mov x0， #0x01
    mov x1, #0x02
    add x2, x0,x1
    ret
    //
    //
    //
    //test 函数实现    
    _test:
    ;bl 指令（函数调用）
    bl mycode        // bl 指令跳转完成后会继续往后面执行
    mov x3, #0x03
    mov x4, #0x04
    ret

    ```
    **bl 指令的本质：**<br>当执行bl指令时，其实其内部做了两件事：<br>（1）将bl 的下一条指令的地址存入lr寄存器。<br>（2）执行bl 指令的跳转。











<br><br>
- 8、 **条件域**<br><br>**作用：** <br>（1）、当处理器工作在ARM 状态时，几所所有的指令均根据**cpsr**中的 条件码的状态 和 指令的条件域 有条件的执行。当指令的执行条件满足时执行。否则忽略不执行。<br> （2）、**每一条ARM 指令包含4位的条件码，位于指令的最高4位（31~28）**。<br> （3)、**条件码共有16种**，每种条件码可由2个字符表示，这两个字符可以添加在指令助记符的后面和指令同时使用。例如：<br> 跳转指令b 可以加上后缀eq变为beq表示“相等则跳转”，即当cpsr中的z标志位置位时跳转。
![](/assets/Snip20180613_1.png)

    ```
    常用条件码翻译：
    eq    // equal相等
    ne    // not equal  不相等
    gt    // great than 大于
    ge    // great equal 大于等于
    lt    // less than 小于
    le    // less equal 小于等于
    ```
    **比如：**
    
    ```
    mov x0, #0x01
    mov x1, #0x02
    cmp x0, x1
    beq mycode    // 这句的含义是x0 -x1相等，即cpsr z 置位时 执行，否则跳过
    mov x0, #0x03
    mycode :
    mov x1, #0x04
    
    还有很多用法，比如：
    bleq abc 
    注意：在Xcode 中 一般指令和条件码之间是有个点分开的，bl.eq
    ```
    ![](/assets/Snip20180613_2.png)<br>
    ![](/assets/Snip20180613_3.png)
    
    
    
    
    
    
- 9、**内存操作**
    - (1)、**从内存读取数据** <br> **ldr、ldur、ldp** ，ld 是load的缩写加载的意思，从内存中读取数据<br>
    **ldr 示例：** 这种寻址统称为 **基址 变址 寻址**
    
    ```
    //
    //
    ldr w0,[x1]    // 从内存地址=x1内存读取4个字节到w0
    ldr x1,[x1]    // 从内存地址=x1内存读取8个字节数据到x1中
    //
    //
    ldr w0, [x1, #0x04]    // 从内存地址=(x1 + #0x04)内存，读取4个字节到w0中
    ldr x0, [x1, #0x08]    // 从内存地址=(x1+#0x08)内存，读取8个字节数据到x1中
    //
    //
    ldr w0, [x1, #0x04]!    // 从内存地址=(x1 + #0x04)内存读取4个字节到w0,后将(x1 + #0x04)的值传送到x1中
    ldr x0, [x1, #0x08]!    // 从内存地址=(x1+#0x08)内存读取8个字节数据到x1中，后将(x1 + #0x08)的值传送到x1中
    //
    //
    ldr w0, [x1], #0x04   // 从内存地址=(x1)内存读取4个字节到w0,后将(x1 + #0x04)的值传送到x1中
    ldr x0, [x1], #0x08    // 从内存地址=(x1)内存读取8个字节数据到x1中，后将(x1 + #0x08)的值传送到x1中
    //
    //
    ldr w0, [x1, x2]   // 从内存地址=(x1+x2)内存读取4个字节到w0
    ldr x0, [x1, x2] // 从内存地址=(x1+x2)内存读取8个字节到x0
    // 也就是说，给定一个内存地址，读取数据时，读取的数据长度由目的寄存器决定。
    ```
    **ldur 示例：**
    
    ```
    //
    //
    ldr w8, [x29,#0x8]    
    ldr x9, [x29,#0x10]
    //
    //
    ldur w8, [x29,#-0x8]    //  可以看出右边的offset（#-0x8）是个负数时使用ldur，offset 是正数时，使用 ldr
    ldur x9, [x29,#-0x10]
    ```
    **ldp 示例：** p是pair的缩写表示的是一对的意思
    
    ```
    ldp x2,x3,[x1,#0x50]     // 表示的是从（x1+#0x50）内存地址读取8个字节的数据到x2,再从 （x1+#0x50）+ 8 的位置读 8个字节的数据到 x3 中
    ldp w2,w3,[x1,#0x50]     // 表示的是从（x1+#0x50）内存地址读取4个字节的数据到w2,再从 （x1+#0x50）+ 4 的位置读 4个字节的数据到 w3 中
```
    - (2)、往内存中写数据
    
    ```
    str x0, [sp, #0x02]  //将 x0 中的数据写入内存= (sp+ #0x02) 8个字节
    str w0, [sp, #0x02]  //将 x0 中的数据写入内存= (sp+ #0x02) 4个字节

    ```
    其实str、stur、stp 和 ldr、ldur、ldp 道理和语法是一样的依次类推。
    













##一、寄存器
- 1、**通用寄存器**
    - x0~x28 : 64位
    - w0~w228: 32位
    - x0~x7 通常用来存放函数的参数，如果还有更多的参数那么会使用堆栈来传递。
    - x0 除了用来存放函数的参数，还有一个最重要的作用就是用来存放函数的返回值。

    
            
- 2、**程序计数器**
    - pc （Program counter），存储（记录）当前正在执行的指令的地址（CPU 正在执行的指令地址），类似于8086 汇编的ip寄存器。



- 3、**堆栈指针寄存器**
    - sp（stack Pointer）
    - fp（Frame Pointer），也就是x29 寄存器
    
    一般来说函数调用，前面实在分配堆栈空间，后面实在回收堆栈空间。
    


- 4、**链接寄存器**(就是x30寄存器，存储的是函数返回的地址)
    - lr（Link Register），也就是x30 寄存器，存储着当前正在执行函数返回后将要执行的下一条指令的地址
    
    
    
    
    
- 5、**程序状态寄存器**
    - cpsr （current Program Status Register），我们 cmp （比较指令的结果就存在cspr 中的）
    - spsr （Saved Program Status Register）异常状态下使用。
    
    
    
- 6、**wzr、xzr零寄存器**，wzr（word zero register） 是32位的，xzr是64位的。<br>**注意：**<br> （1）、我们在lldb 中是 读不出zer 和 xzr 的，但是在代码里是经常能看到的。
```
stur wzr,[x29, #-0x14]     // 往内存中写0
stur xzr,[x29, #-0x20]     // 往内存中写0
```
wzr、xzr 的主要作用是 置0 、清零 操作。


####汇编函数调用

- 函数的类型
    - 叶子函数，所谓叶子函数就是其内部不再调用其它函数的函数，如下：
    
    ```
    // 叶子函数
    void haha(){
        int a = 2;
        int b = 3;
    }

    ```
    具体汇编调用如下：
    ![](/assets/Snip20180613_5.png)
    
    
    
    - 非叶子函数，所谓非叶子函数，指的是函数内部有调用其他的函数，如下：
    
    ```
    // 非叶子函数
    void test{
        int a = 10;
        int b = 12;
        return  sum(a ,b);
    }
    ```
    
    
    
    
    